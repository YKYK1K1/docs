(window.webpackJsonp=window.webpackJsonp||[]).push([[105],{860:function(t,e,a){"use strict";a.r(e);var n=a(67),r=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"spring-boot-响应式客户端-webclient"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring-boot-响应式客户端-webclient"}},[t._v("#")]),t._v(" "),a("strong",[t._v("Spring Boot 响应式客户端 WebClient")])]),t._v(" "),a("h2",{attrs:{id:"简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" "),a("strong",[t._v("简介")])]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("WebClient 是一个响应式客户端，它提供了RestTemplate的替代方法。它公开了一个功能齐全、流畅的API，并依赖于非阻塞I / O，使其能够比 RestTemplate 更高效地支持高并发性。WebClient 非常适合流式的传输方案，并且依赖于较低级别的 HTTP 客户端库来执行请求，是可插拔的。")]),t._v(" "),a("p",[t._v("WebClient 使用与 WebFlux 服务器应用程序相同的编解码器，并与服务器功能Web框架共享公共基本包，一些通用API和基础结构。API 公开了 Reactor Flux 和 Mono 类型。默认情况下，它使用 Reactor Netty 作为 HTTP 客户端库，但其他人可以通过自定义 ClientHttpConnector 插入。")]),t._v(" "),a("h2",{attrs:{id:"优点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[t._v("#")]),t._v(" "),a("strong",[t._v("优点")])]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("与 RestTemplate 相比，WebClient是：")]),t._v(" "),a("ul",[a("li",[t._v("非阻塞，Reactive的，并支持更高的并发性和更少的硬件资源。")]),t._v(" "),a("li",[t._v("提供利用Java 8 lambdas的函数API。")]),t._v(" "),a("li",[t._v("支持同步和异步方案。")]),t._v(" "),a("li",[t._v("支持从服务器向上或向下流式传输。")])]),t._v(" "),a("p",[t._v("RestTemplate不适合在非阻塞应用程序中使用，因此 Spring WebFlux 应用程序应始终使用 WebClient。在大多数高并发场景中，WebClient 也应该是 Spring MVC 中的首选，并且用于编写一系列远程，相互依赖的调用。")])])}),[],!1,null,null,null);e.default=r.exports}}]);