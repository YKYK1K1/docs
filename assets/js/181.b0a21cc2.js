(window.webpackJsonp=window.webpackJsonp||[]).push([[181],{936:function(n,t,e){"use strict";e.r(t);var o=e(67),r=Object(o.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"spring与loc"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring与loc"}},[n._v("#")]),n._v(" "),e("strong",[n._v("Spring与loc")])]),n._v(" "),e("p",[n._v("控制反转( loC,Inversion of Control),是一个概念,是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移,从程序代码本身反转到了外部容器。")]),n._v(" "),e("p",[n._v("loC是一个概念,是一种思想,其实现方式多种多样。当前比较流行的实现方式有两种:依赖注入和依赖查找。依赖注入方式应用更为广泛。")]),n._v(" "),e("ul",[e("li",[n._v("依赖查找: DependencyLookup,DL,容器提供回调接口和上下文环境给组件,程序代码则需要提供具体的查找方式比较典型的是依赖于JNDI系统的查找。")]),n._v(" "),e("li",[e("strong",[n._v("依赖注入")]),n._v(": Dependency Injection,DI,程序代码不做定位查询,这些工作由容器自行完成。")])]),n._v(" "),e("p",[n._v("依赖注入DI是指程序运行过程中,若需要调用另一个对象协助时,无须在代码中创建被调用者,而是依赖于外部容器,由外部容器创建后传递给程序。")]),n._v(" "),e("p",[n._v("Spring的依赖注入对调用者与被调用者几乎没有任何要求,完全支持POJO之间依赖关系的管理。")]),n._v(" "),e("p",[e("strong",[n._v("依赖注入是目前最优秀的解耦方式")]),n._v("。依赖注入让Spring的Bean之间以配置文件的方式组织在一起,而不是以硬编码的方式耦合在一起的。")])])}),[],!1,null,null,null);t.default=r.exports}}]);