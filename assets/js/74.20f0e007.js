(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{829:function(e,t,o){"use strict";o.r(t);var v=o(67),_=Object(v.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"kubernetes"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#kubernetes"}},[e._v("#")]),e._v(" "),o("strong",[e._v("Kubernetes")])]),e._v(" "),o("div",{staticClass:"custom-block tip"},[o("p",{staticClass:"custom-block-title"},[e._v("提示")]),e._v(" "),o("p",[e._v("MESOS APACHE 分布式资源管理框架  2019-5 Twitter > Kubernetes")]),e._v(" "),o("p",[e._v("Docker Swarm  2019-7  阿里云宣布  Docker Swarm 剔除")]),e._v(" "),o("p",[e._v("Kubernetes Google  10年容器化基础架构  borg  GO 语言  Borg\n特点:\n轻量级: 消耗资源小\n开源\n弹性伸缩\n负载均衡: IPVS")])]),e._v(" "),o("h2",{attrs:{id:"知识目录"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#知识目录"}},[e._v("#")]),e._v(" "),o("strong",[e._v("知识目录")])]),e._v(" "),o("hr"),e._v(" "),o("ol",[o("li",[e._v("介绍说明:    前世今生    Kubernetes 框架 kubernetes关键字含义")]),e._v(" "),o("li",[e._v("基础概念:    什么是Pod   控制类型    K8S 网络通讯模式")]),e._v(" "),o("li",[e._v("Kubernetes:  构建 K8S 集群")]),e._v(" "),o("li",[e._v("资源清单:    资源    掌握资源清单的语法  编写 Pod    "),o("strong",[e._v("掌握 Pod 的生命周期")])]),e._v(" "),o("li",[e._v("Pod 控制器:  掌握各种控制器的特点以及使用定义的方式")]),e._v(" "),o("li",[e._v("服务发现:    掌握 SVC 原理及其构建方式")]),e._v(" "),o("li",[e._v("存储:    掌握多种存储类型的特点，并且能够在不同环境中选择合适的存储方案(要有自己的见解)")]),e._v(" "),o("li",[e._v("调度器:  掌握调度器原理  能够根据要求把 Pod 定义到想要的节点运行")]),e._v(" "),o("li",[e._v("安全:    集群的认证  鉴权    访问控制    原理及其流程")]),e._v(" "),o("li",[e._v("HELM:   Linux yum   掌握 HELM 原理  HELM 模板自定义 HELM 部署常用的插件")]),e._v(" "),o("li",[e._v("运维:   修改 kubeadm  达到证书可用期限为 10 年  能够构建高可用的 Kubernetes 集群")])]),e._v(" "),o("h2",{attrs:{id:"组件说明"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#组件说明"}},[e._v("#")]),e._v(" "),o("strong",[e._v("组件说明")])]),e._v(" "),o("hr"),e._v(" "),o("h3",{attrs:{id:"google-borg"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#google-borg"}},[e._v("#")]),e._v(" "),o("strong",[e._v("google Borg")])]),e._v(" "),o("p",[o("img",{attrs:{src:"/docs/assets/k8s/yky-2020-08-24-150447.png",alt:"Borg"}})]),e._v(" "),o("p",[e._v("::: erro 重点\n高可用集群副本数据最好 >= 3 (奇数个)\n:::")]),e._v(" "),o("h3",{attrs:{id:"k8s"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#k8s"}},[e._v("#")]),e._v(" "),o("strong",[e._v("k8s")])]),e._v(" "),o("p",[o("img",{attrs:{src:"/docs/assets/k8s/yky-2020-08-24-150741.png",alt:"K8S"}})]),e._v(" "),o("div",{staticClass:"custom-block tip"},[o("p",{staticClass:"custom-block-title"},[e._v("提示")]),e._v(" "),o("p",[o("code",[e._v("ApiServer")]),e._v(":  所有服务访问统一入口")]),e._v(" "),o("p",[o("code",[e._v("ControllerManager")]),e._v(":  维持副本期望数目")]),e._v(" "),o("p",[o("code",[e._v("Scheduler")]),e._v(":  负责介绍任务，选择合适的节点进行分配任务")]),e._v(" "),o("p",[o("code",[e._v("ETCD")]),e._v(":   键值对数据库 存储 K8S 集群所有重要信息(持久化)")]),e._v(" "),o("p",[o("code",[e._v("Kubelet")]),e._v(":    直接跟容器引擎交互实现容器的生命周期管理")]),e._v(" "),o("p",[o("code",[e._v("Kube-proxy")]),e._v(": 负责写入规则至 IPTABLES、IPVS 实现服务映射访问的")])]),e._v(" "),o("blockquote",[o("p",[e._v("etcd 的官方将它定位成一个可信赖的分布式键值存储服务,它能够为整个分布式集群存储一些关键数据,协助分布式集群的正常运转")])]),e._v(" "),o("p",[o("img",{attrs:{src:"/docs/assets/k8s/yky-2020-08-24-150959.png",alt:"ETCD"}})]),e._v(" "),o("blockquote",[o("p",[e._v("推荐在Kubernetes集群中使用Etcd v3, v2版本已在 Kubernetes v1.11 中弃用")])]),e._v(" "),o("p",[o("img",{attrs:{src:"/docs/assets/k8s/yky-2020-08-24-163414.png",alt:"ETCD"}})]),e._v(" "),o("p",[o("img",{attrs:{src:"/docs/assets/k8s/yky-2020-08-25-092700.png",alt:"其他插件"}})]),e._v(" "),o("div",{staticClass:"custom-block tip"},[o("p",{staticClass:"custom-block-title"},[e._v("提示")]),e._v(" "),o("p",[o("code",[e._v("CoreDNS")]),e._v(":    可以为集群中的 SVC 创建一个域名 IP 的对应关系解析")]),e._v(" "),o("p",[o("code",[e._v("Dashboard")]),e._v(":  给 K8S 集群提供一个 B/S 结构访问体系")]),e._v(" "),o("p",[o("code",[e._v("Ingress Controller")]),e._v(":   官方只能实现四层代理，INGRESS 可以实现七层代理")]),e._v(" "),o("p",[o("code",[e._v("Federation")]),e._v(":   提供一个可以跨集群中心多 K8S 统一管理功能")]),e._v(" "),o("p",[o("code",[e._v("Prometheus")]),e._v(":   提供一个 K8S 集群的监控能力")]),e._v(" "),o("p",[o("code",[e._v("ELK")]),e._v(":  提供 K8S 集群日志统一分析介入平台")])]),e._v(" "),o("h2",{attrs:{id:"pod-概念"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#pod-概念"}},[e._v("#")]),e._v(" "),o("strong",[e._v("Pod 概念")])]),e._v(" "),o("hr"),e._v(" "),o("h3",{attrs:{id:"类型"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#类型"}},[e._v("#")]),e._v(" "),o("strong",[e._v("类型")])]),e._v(" "),o("ul",[o("li",[o("strong",[e._v("自主式 Pod")])]),e._v(" "),o("li",[o("strong",[e._v("控制器管理的 Pod")])])]),e._v(" "),o("h2",{attrs:{id:"控制器类型"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#控制器类型"}},[e._v("#")]),e._v(" "),o("strong",[e._v("控制器类型")])]),e._v(" "),o("hr"),e._v(" "),o("h3",{attrs:{id:"replicationcontroller-replicaset-deployment"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#replicationcontroller-replicaset-deployment"}},[e._v("#")]),e._v(" "),o("strong",[e._v("ReplicationController & ReplicaSet & Deployment")])]),e._v(" "),o("p",[o("code",[e._v("ReplicationController")]),e._v("用来确保容器应用的副本数始终保持在用户定义的副本数,即如果有容器异常退出,会自动创建新的 Pod 来替代;而如果异常多出来的容器也会自动回收.\n在新版本的"),o("code",[e._v("Kubernetes")]),e._v("中建议使用"),o("code",[e._v("ReplicaSet")]),e._v("来取代"),o("code",[e._v("ReplicationController")])]),e._v(" "),o("p",[o("code",[e._v("ReplicaSet")]),e._v("跟"),o("code",[e._v("ReplicationController")]),e._v("没有本质的不同,只是名字不一样,并且"),o("code",[e._v("ReplicaSet")]),e._v("支持集合式的"),o("code",[e._v("selecton")])]),e._v(" "),o("p",[e._v("虽然"),o("code",[e._v("ReplicaSet")]),e._v("可以独立使用,但一般还是建议使用"),o("code",[e._v("Deployment")]),e._v("来自动管理"),o("code",[e._v("ReplicaSet")]),e._v(",这样就无需担心跟其他机制的不兼容问题(比如"),o("code",[e._v("ReplicaSet")]),e._v("不支持"),o("code",[e._v("rolling-update")]),e._v("但"),o("code",[e._v("Deployment")]),e._v(" 支持)")]),e._v(" "),o("h3",{attrs:{id:"deployment-replicaset"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#deployment-replicaset"}},[e._v("#")]),e._v(" "),o("strong",[e._v("Deployment(ReplicaSet)")])]),e._v(" "),o("p",[o("code",[e._v("Deployment")]),e._v("为 Pod 和"),o("code",[e._v("ReplicaSet")]),e._v("提供了一个声明式定义(declarative)方法,用来普代以前的"),o("code",[e._v("ReplicationController")]),e._v("来方便的管理应用.典型的应用场景包括")]),e._v(" "),o("ul",[o("li",[o("strong",[e._v("定义"),o("code",[e._v("Deploynent")]),e._v("来创建 Pod 和"),o("code",[e._v("ReplicaSet")])])]),e._v(" "),o("li",[o("strong",[e._v("滚动升級和回滚应用")])]),e._v(" "),o("li",[o("strong",[e._v("扩容和缩容")])]),e._v(" "),o("li",[o("strong",[e._v("暂停和继续"),o("code",[e._v("Deployment")])])])]),e._v(" "),o("h3",{attrs:{id:"hpa-horizontalpodautoscale"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#hpa-horizontalpodautoscale"}},[e._v("#")]),e._v(" "),o("strong",[e._v("HPA (HorizontalPodAutoScale)")])]),e._v(" "),o("p",[o("code",[e._v("Horizontal Pod Autoscaling")]),e._v("仅适用于"),o("code",[e._v("Deployment")]),e._v("和"),o("code",[e._v("ReplicaSet")]),e._v(" ,在 V1 版本中仅支持根据 Pod 的 CPU 利用率扩所容,在 vlalpha 版本中,支持根据内存和用户自定义的 metric 扩缩容")]),e._v(" "),o("h3",{attrs:{id:"statefulset"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#statefulset"}},[e._v("#")]),e._v(" "),o("strong",[e._v("StatefulSet")])]),e._v(" "),o("p",[o("code",[e._v("StatefulSet")]),e._v("是为了解决有状态服务的问题(对应"),o("code",[e._v("Deployments")]),e._v("和"),o("code",[e._v("ReplicaSets")]),e._v("是为无状态服务而设计),其应用场景包括:")]),e._v(" "),o("ul",[o("li",[o("strong",[e._v("稳定的持久化存储,即 Pod 重新调度后还是能访问到相同的持久化数据,基于 PVC 来实现")])]),e._v(" "),o("li",[o("strong",[e._v('稳定的网络标志,即 Pod 重新调度后其 PodName 和 HostName 不变,基于 Headless Service" (即没有 Cluster IP 的Service )来实现')])]),e._v(" "),o("li",[o("strong",[e._v("有序部署,有序扩展,即 Pod 是有顺序的,在部署或者扩展的时候要依据定义的顺序依次依次进行(即从 0 到 N-1,在下一个 Pod 运行之前所有之前的 Pod 必须都是 Running 和 Ready 状态) ,基于 init containers 来实现")])]),e._v(" "),o("li",[o("strong",[e._v("有序收缩,有序删除(即从 N-1 到 0)")])])]),e._v(" "),o("h3",{attrs:{id:"daemonset"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#daemonset"}},[e._v("#")]),e._v(" "),o("strong",[e._v("DaemonSet")])]),e._v(" "),o("p",[o("code",[e._v("DaemonSet")]),e._v("确保全部(或者一些) Node上运行一个 Pod 的副本.当有 Node 加入樂群时,也会为他们新增一个 Pod .当有 Node 从集群移除时,这些 Pod 也会被回收.删除"),o("code",[e._v("DaemonSet")]),e._v("将会删除它创建的所有 Pod\n使用"),o("code",[e._v("DaemonSet")]),e._v("的一些典型用法:")]),e._v(" "),o("ul",[o("li",[o("strong",[e._v("运行集群存储 daemon,例如在每个 Node 上运行 glusterd, ceph")])]),e._v(" "),o("li",[o("strong",[e._v("在每个 Node 上运行日志收集 daemon,例如 fluentd, 1ogstash")])]),e._v(" "),o("li",[o("strong",[e._v("在每个 Node 上运行监控 daemon,例如 Prometheus Node Exporter")])])]),e._v(" "),o("h3",{attrs:{id:"job-cronjob"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#job-cronjob"}},[e._v("#")]),e._v(" "),o("strong",[e._v("Job,Cronjob")])]),e._v(" "),o("p",[o("code",[e._v("Job")]),e._v("负责批处理任务,即仅执行一次的任务,它保证批处理任务的一个或多个 Pod 成功结束. "),o("code",[e._v("Cron Job")]),e._v("管理基于时间的 Job,即:")]),e._v(" "),o("ul",[o("li",[o("strong",[e._v("在给定时间点只运行一次")])]),e._v(" "),o("li",[o("strong",[e._v("周期性地在给定时间点运行")])])])])}),[],!1,null,null,null);t.default=_.exports}}]);